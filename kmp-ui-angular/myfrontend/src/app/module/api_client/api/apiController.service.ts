/**
 * KMP API
 * KMP 에서 제공하는 API를 확인하고 테스트 해볼 수 있습니다.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: jdlee726@gmail.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { Balance } from '../model/balance';
import { CallbackLog } from '../model/callbackLog';
import { Chart } from '../model/chart';
import { MultiAddress } from '../model/multiAddress';
import { ReceivePayment } from '../model/receivePayment';
import { Stats } from '../model/stats';
import { Ticker } from '../model/ticker';
import { UnspentOutputs } from '../model/unspentOutputs';
import { XpubGap } from '../model/xpubGap';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class ApiControllerService {

    protected basePath = 'https://localhost:8080';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * callbackLog
     * 
     * @param callback callback
     * @param key key
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public callbackLogUsingGET(callback: string, key: string, observe?: 'body', reportProgress?: boolean): Observable<Array<CallbackLog>>;
    public callbackLogUsingGET(callback: string, key: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CallbackLog>>>;
    public callbackLogUsingGET(callback: string, key: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CallbackLog>>>;
    public callbackLogUsingGET(callback: string, key: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (callback === null || callback === undefined) {
            throw new Error('Required parameter callback was null or undefined when calling callbackLogUsingGET.');
        }
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling callbackLogUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (callback !== undefined) {
            queryParameters = queryParameters.set('callback', <any>callback);
        }
        if (key !== undefined) {
            queryParameters = queryParameters.set('key', <any>key);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Array<CallbackLog>>(`${this.basePath}/v2/receive/callback_log`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * checkGap
     * 
     * @param xpub xpub
     * @param key key
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public checkGapUsingGET(xpub: string, key: string, observe?: 'body', reportProgress?: boolean): Observable<XpubGap>;
    public checkGapUsingGET(xpub: string, key: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<XpubGap>>;
    public checkGapUsingGET(xpub: string, key: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<XpubGap>>;
    public checkGapUsingGET(xpub: string, key: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (xpub === null || xpub === undefined) {
            throw new Error('Required parameter xpub was null or undefined when calling checkGapUsingGET.');
        }
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling checkGapUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (xpub !== undefined) {
            queryParameters = queryParameters.set('xpub', <any>xpub);
        }
        if (key !== undefined) {
            queryParameters = queryParameters.set('key', <any>key);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<XpubGap>(`${this.basePath}/v2/receive/checkgap`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * fromBTC
     * 
     * @param currency currency
     * @param value value
     * @param api_code api_code
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public fromBTCUsingGET(currency: string, value: number, api_code: string, observe?: 'body', reportProgress?: boolean): Observable<number>;
    public fromBTCUsingGET(currency: string, value: number, api_code: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<number>>;
    public fromBTCUsingGET(currency: string, value: number, api_code: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<number>>;
    public fromBTCUsingGET(currency: string, value: number, api_code: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling fromBTCUsingGET.');
        }
        if (value === null || value === undefined) {
            throw new Error('Required parameter value was null or undefined when calling fromBTCUsingGET.');
        }
        if (api_code === null || api_code === undefined) {
            throw new Error('Required parameter api_code was null or undefined when calling fromBTCUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (currency !== undefined) {
            queryParameters = queryParameters.set('currency', <any>currency);
        }
        if (value !== undefined) {
            queryParameters = queryParameters.set('value', <any>value);
        }
        if (api_code !== undefined) {
            queryParameters = queryParameters.set('api_code', <any>api_code);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<number>(`${this.basePath}/frombtc`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * fromETH
     * 
     * @param currency currency
     * @param value value
     * @param api_code api_code
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public fromETHUsingGET(currency: string, value: string, api_code: string, observe?: 'body', reportProgress?: boolean): Observable<number>;
    public fromETHUsingGET(currency: string, value: string, api_code: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<number>>;
    public fromETHUsingGET(currency: string, value: string, api_code: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<number>>;
    public fromETHUsingGET(currency: string, value: string, api_code: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling fromETHUsingGET.');
        }
        if (value === null || value === undefined) {
            throw new Error('Required parameter value was null or undefined when calling fromETHUsingGET.');
        }
        if (api_code === null || api_code === undefined) {
            throw new Error('Required parameter api_code was null or undefined when calling fromETHUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (currency !== undefined) {
            queryParameters = queryParameters.set('currency', <any>currency);
        }
        if (value !== undefined) {
            queryParameters = queryParameters.set('value', <any>value);
        }
        if (api_code !== undefined) {
            queryParameters = queryParameters.set('api_code', <any>api_code);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<number>(`${this.basePath}/frometh`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getBalance
     * 
     * @param coin coin
     * @param active active
     * @param filter filter
     * @param api_code api_code
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getBalanceUsingPOST(coin: string, active: string, filter: number, api_code: string, observe?: 'body', reportProgress?: boolean): Observable<{ [key: string]: Balance; }>;
    public getBalanceUsingPOST(coin: string, active: string, filter: number, api_code: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{ [key: string]: Balance; }>>;
    public getBalanceUsingPOST(coin: string, active: string, filter: number, api_code: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<{ [key: string]: Balance; }>>;
    public getBalanceUsingPOST(coin: string, active: string, filter: number, api_code: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (coin === null || coin === undefined) {
            throw new Error('Required parameter coin was null or undefined when calling getBalanceUsingPOST.');
        }
        if (active === null || active === undefined) {
            throw new Error('Required parameter active was null or undefined when calling getBalanceUsingPOST.');
        }
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling getBalanceUsingPOST.');
        }
        if (api_code === null || api_code === undefined) {
            throw new Error('Required parameter api_code was null or undefined when calling getBalanceUsingPOST.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (active !== undefined) {
            queryParameters = queryParameters.set('active', <any>active);
        }
        if (filter !== undefined) {
            queryParameters = queryParameters.set('filter', <any>filter);
        }
        if (api_code !== undefined) {
            queryParameters = queryParameters.set('api_code', <any>api_code);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.post<{ [key: string]: Balance; }>(`${this.basePath}/${encodeURIComponent(String(coin))}/balance`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getBtcTicker
     * 
     * @param api_code api_code
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getBtcTickerUsingGET(api_code: string, observe?: 'body', reportProgress?: boolean): Observable<Ticker>;
    public getBtcTickerUsingGET(api_code: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Ticker>>;
    public getBtcTickerUsingGET(api_code: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Ticker>>;
    public getBtcTickerUsingGET(api_code: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (api_code === null || api_code === undefined) {
            throw new Error('Required parameter api_code was null or undefined when calling getBtcTickerUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (api_code !== undefined) {
            queryParameters = queryParameters.set('api_code', <any>api_code);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Ticker>(`${this.basePath}/ticker`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getChart
     * 
     * @param chart_type chart-type
     * @param timespan timespan
     * @param rollingAverage rollingAverage
     * @param format format
     * @param api_code api_code
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getChartUsingGET(chart_type: string, timespan: string, rollingAverage: string, format: string, api_code: string, observe?: 'body', reportProgress?: boolean): Observable<Chart>;
    public getChartUsingGET(chart_type: string, timespan: string, rollingAverage: string, format: string, api_code: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Chart>>;
    public getChartUsingGET(chart_type: string, timespan: string, rollingAverage: string, format: string, api_code: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Chart>>;
    public getChartUsingGET(chart_type: string, timespan: string, rollingAverage: string, format: string, api_code: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (chart_type === null || chart_type === undefined) {
            throw new Error('Required parameter chart_type was null or undefined when calling getChartUsingGET.');
        }
        if (timespan === null || timespan === undefined) {
            throw new Error('Required parameter timespan was null or undefined when calling getChartUsingGET.');
        }
        if (rollingAverage === null || rollingAverage === undefined) {
            throw new Error('Required parameter rollingAverage was null or undefined when calling getChartUsingGET.');
        }
        if (format === null || format === undefined) {
            throw new Error('Required parameter format was null or undefined when calling getChartUsingGET.');
        }
        if (api_code === null || api_code === undefined) {
            throw new Error('Required parameter api_code was null or undefined when calling getChartUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (timespan !== undefined) {
            queryParameters = queryParameters.set('timespan', <any>timespan);
        }
        if (rollingAverage !== undefined) {
            queryParameters = queryParameters.set('rollingAverage', <any>rollingAverage);
        }
        if (format !== undefined) {
            queryParameters = queryParameters.set('format', <any>format);
        }
        if (api_code !== undefined) {
            queryParameters = queryParameters.set('api_code', <any>api_code);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Chart>(`${this.basePath}/charts/${encodeURIComponent(String(chart_type))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getMultiAddress
     * 
     * @param coin coin
     * @param active active
     * @param n n
     * @param offset offset
     * @param filter filter
     * @param onlyShow onlyShow
     * @param api_code api_code
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMultiAddressUsingPOST(coin: string, active: string, n: number, offset: number, filter: number, onlyShow: string, api_code: string, observe?: 'body', reportProgress?: boolean): Observable<MultiAddress>;
    public getMultiAddressUsingPOST(coin: string, active: string, n: number, offset: number, filter: number, onlyShow: string, api_code: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<MultiAddress>>;
    public getMultiAddressUsingPOST(coin: string, active: string, n: number, offset: number, filter: number, onlyShow: string, api_code: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<MultiAddress>>;
    public getMultiAddressUsingPOST(coin: string, active: string, n: number, offset: number, filter: number, onlyShow: string, api_code: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (coin === null || coin === undefined) {
            throw new Error('Required parameter coin was null or undefined when calling getMultiAddressUsingPOST.');
        }
        if (active === null || active === undefined) {
            throw new Error('Required parameter active was null or undefined when calling getMultiAddressUsingPOST.');
        }
        if (n === null || n === undefined) {
            throw new Error('Required parameter n was null or undefined when calling getMultiAddressUsingPOST.');
        }
        if (offset === null || offset === undefined) {
            throw new Error('Required parameter offset was null or undefined when calling getMultiAddressUsingPOST.');
        }
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling getMultiAddressUsingPOST.');
        }
        if (onlyShow === null || onlyShow === undefined) {
            throw new Error('Required parameter onlyShow was null or undefined when calling getMultiAddressUsingPOST.');
        }
        if (api_code === null || api_code === undefined) {
            throw new Error('Required parameter api_code was null or undefined when calling getMultiAddressUsingPOST.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (active !== undefined) {
            queryParameters = queryParameters.set('active', <any>active);
        }
        if (n !== undefined) {
            queryParameters = queryParameters.set('n', <any>n);
        }
        if (offset !== undefined) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (filter !== undefined) {
            queryParameters = queryParameters.set('filter', <any>filter);
        }
        if (onlyShow !== undefined) {
            queryParameters = queryParameters.set('onlyShow', <any>onlyShow);
        }
        if (api_code !== undefined) {
            queryParameters = queryParameters.set('api_code', <any>api_code);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.post<MultiAddress>(`${this.basePath}/${encodeURIComponent(String(coin))}/multiaddr`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getPools
     * 
     * @param timespan timespan
     * @param api_code api_code
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPoolsUsingGET(timespan: string, api_code: string, observe?: 'body', reportProgress?: boolean): Observable<{ [key: string]: number; }>;
    public getPoolsUsingGET(timespan: string, api_code: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{ [key: string]: number; }>>;
    public getPoolsUsingGET(timespan: string, api_code: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<{ [key: string]: number; }>>;
    public getPoolsUsingGET(timespan: string, api_code: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (timespan === null || timespan === undefined) {
            throw new Error('Required parameter timespan was null or undefined when calling getPoolsUsingGET.');
        }
        if (api_code === null || api_code === undefined) {
            throw new Error('Required parameter api_code was null or undefined when calling getPoolsUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (timespan !== undefined) {
            queryParameters = queryParameters.set('timespan', <any>timespan);
        }
        if (api_code !== undefined) {
            queryParameters = queryParameters.set('api_code', <any>api_code);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<{ [key: string]: number; }>(`${this.basePath}/pools`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getStats
     * 
     * @param api_code api_code
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getStatsUsingGET(api_code: string, observe?: 'body', reportProgress?: boolean): Observable<Stats>;
    public getStatsUsingGET(api_code: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Stats>>;
    public getStatsUsingGET(api_code: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Stats>>;
    public getStatsUsingGET(api_code: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (api_code === null || api_code === undefined) {
            throw new Error('Required parameter api_code was null or undefined when calling getStatsUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (api_code !== undefined) {
            queryParameters = queryParameters.set('api_code', <any>api_code);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Stats>(`${this.basePath}/stats`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getUnspent
     * 
     * @param coin coin
     * @param active active
     * @param confirmations confirmations
     * @param limit limit
     * @param api_code api_code
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUnspentUsingGET(coin: string, active: string, confirmations: number, limit: number, api_code: string, observe?: 'body', reportProgress?: boolean): Observable<UnspentOutputs>;
    public getUnspentUsingGET(coin: string, active: string, confirmations: number, limit: number, api_code: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UnspentOutputs>>;
    public getUnspentUsingGET(coin: string, active: string, confirmations: number, limit: number, api_code: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UnspentOutputs>>;
    public getUnspentUsingGET(coin: string, active: string, confirmations: number, limit: number, api_code: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (coin === null || coin === undefined) {
            throw new Error('Required parameter coin was null or undefined when calling getUnspentUsingGET.');
        }
        if (active === null || active === undefined) {
            throw new Error('Required parameter active was null or undefined when calling getUnspentUsingGET.');
        }
        if (confirmations === null || confirmations === undefined) {
            throw new Error('Required parameter confirmations was null or undefined when calling getUnspentUsingGET.');
        }
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling getUnspentUsingGET.');
        }
        if (api_code === null || api_code === undefined) {
            throw new Error('Required parameter api_code was null or undefined when calling getUnspentUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (active !== undefined) {
            queryParameters = queryParameters.set('active', <any>active);
        }
        if (confirmations !== undefined) {
            queryParameters = queryParameters.set('confirmations', <any>confirmations);
        }
        if (limit !== undefined) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (api_code !== undefined) {
            queryParameters = queryParameters.set('api_code', <any>api_code);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<UnspentOutputs>(`${this.basePath}/${encodeURIComponent(String(coin))}/unspent`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * pushTx
     * 
     * @param coin coin
     * @param tx tx
     * @param api_code api_code
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pushTxUsingPOST(coin: string, tx: string, api_code: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public pushTxUsingPOST(coin: string, tx: string, api_code: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public pushTxUsingPOST(coin: string, tx: string, api_code: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public pushTxUsingPOST(coin: string, tx: string, api_code: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (coin === null || coin === undefined) {
            throw new Error('Required parameter coin was null or undefined when calling pushTxUsingPOST.');
        }
        if (tx === null || tx === undefined) {
            throw new Error('Required parameter tx was null or undefined when calling pushTxUsingPOST.');
        }
        if (api_code === null || api_code === undefined) {
            throw new Error('Required parameter api_code was null or undefined when calling pushTxUsingPOST.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (tx !== undefined) {
            queryParameters = queryParameters.set('tx', <any>tx);
        }
        if (api_code !== undefined) {
            queryParameters = queryParameters.set('api_code', <any>api_code);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.post<string>(`${this.basePath}/${encodeURIComponent(String(coin))}/pushtx`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * receive
     * 
     * @param xpub xpub
     * @param callback callback
     * @param gap_limit gap_limit
     * @param index index
     * @param key key
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public receiveUsingGET(xpub: string, callback: string, gap_limit: number, index: number, key: string, observe?: 'body', reportProgress?: boolean): Observable<ReceivePayment>;
    public receiveUsingGET(xpub: string, callback: string, gap_limit: number, index: number, key: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ReceivePayment>>;
    public receiveUsingGET(xpub: string, callback: string, gap_limit: number, index: number, key: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ReceivePayment>>;
    public receiveUsingGET(xpub: string, callback: string, gap_limit: number, index: number, key: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (xpub === null || xpub === undefined) {
            throw new Error('Required parameter xpub was null or undefined when calling receiveUsingGET.');
        }
        if (callback === null || callback === undefined) {
            throw new Error('Required parameter callback was null or undefined when calling receiveUsingGET.');
        }
        if (gap_limit === null || gap_limit === undefined) {
            throw new Error('Required parameter gap_limit was null or undefined when calling receiveUsingGET.');
        }
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling receiveUsingGET.');
        }
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling receiveUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (xpub !== undefined) {
            queryParameters = queryParameters.set('xpub', <any>xpub);
        }
        if (callback !== undefined) {
            queryParameters = queryParameters.set('callback', <any>callback);
        }
        if (gap_limit !== undefined) {
            queryParameters = queryParameters.set('gap_limit', <any>gap_limit);
        }
        if (index !== undefined) {
            queryParameters = queryParameters.set('index', <any>index);
        }
        if (key !== undefined) {
            queryParameters = queryParameters.set('key', <any>key);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<ReceivePayment>(`${this.basePath}/v2/receive`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * toBTC
     * 
     * @param currency currency
     * @param value value
     * @param api_code api_code
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public toBTCUsingGET(currency: string, value: number, api_code: string, observe?: 'body', reportProgress?: boolean): Observable<number>;
    public toBTCUsingGET(currency: string, value: number, api_code: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<number>>;
    public toBTCUsingGET(currency: string, value: number, api_code: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<number>>;
    public toBTCUsingGET(currency: string, value: number, api_code: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling toBTCUsingGET.');
        }
        if (value === null || value === undefined) {
            throw new Error('Required parameter value was null or undefined when calling toBTCUsingGET.');
        }
        if (api_code === null || api_code === undefined) {
            throw new Error('Required parameter api_code was null or undefined when calling toBTCUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (currency !== undefined) {
            queryParameters = queryParameters.set('currency', <any>currency);
        }
        if (value !== undefined) {
            queryParameters = queryParameters.set('value', <any>value);
        }
        if (api_code !== undefined) {
            queryParameters = queryParameters.set('api_code', <any>api_code);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<number>(`${this.basePath}/tobtc`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * toETH
     * 
     * @param currency currency
     * @param value value
     * @param api_code api_code
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public toETHUsingGET(currency: string, value: number, api_code: string, observe?: 'body', reportProgress?: boolean): Observable<number>;
    public toETHUsingGET(currency: string, value: number, api_code: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<number>>;
    public toETHUsingGET(currency: string, value: number, api_code: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<number>>;
    public toETHUsingGET(currency: string, value: number, api_code: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling toETHUsingGET.');
        }
        if (value === null || value === undefined) {
            throw new Error('Required parameter value was null or undefined when calling toETHUsingGET.');
        }
        if (api_code === null || api_code === undefined) {
            throw new Error('Required parameter api_code was null or undefined when calling toETHUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (currency !== undefined) {
            queryParameters = queryParameters.set('currency', <any>currency);
        }
        if (value !== undefined) {
            queryParameters = queryParameters.set('value', <any>value);
        }
        if (api_code !== undefined) {
            queryParameters = queryParameters.set('api_code', <any>api_code);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<number>(`${this.basePath}/toeth`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
