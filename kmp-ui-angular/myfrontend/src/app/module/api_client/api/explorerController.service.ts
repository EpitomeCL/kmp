/**
 * KMP API
 * KMP 에서 제공하는 API를 확인하고 테스트 해볼 수 있습니다.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: jdlee726@gmail.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { AddressFull } from '../model/addressFull';
import { Balance } from '../model/balance';
import { Block } from '../model/block';
import { ExportHistory } from '../model/exportHistory';
import { MultiAddress } from '../model/multiAddress';
import { RawBlock } from '../model/rawBlock';
import { RawBlocks } from '../model/rawBlocks';
import { Transaction } from '../model/transaction';
import { Transactions } from '../model/transactions';
import { UnspentOutputs } from '../model/unspentOutputs';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class ExplorerControllerService {

    protected basePath = 'https://localhost:8080';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * getAddress
     * 
     * @param addr addr
     * @param limit limit
     * @param offset offset
     * @param filter filter
     * @param format format
     * @param api_code api_code
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAddressUsingGET(addr: string, limit: number, offset: number, filter: number, format: string, api_code: string, observe?: 'body', reportProgress?: boolean): Observable<AddressFull>;
    public getAddressUsingGET(addr: string, limit: number, offset: number, filter: number, format: string, api_code: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AddressFull>>;
    public getAddressUsingGET(addr: string, limit: number, offset: number, filter: number, format: string, api_code: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AddressFull>>;
    public getAddressUsingGET(addr: string, limit: number, offset: number, filter: number, format: string, api_code: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (addr === null || addr === undefined) {
            throw new Error('Required parameter addr was null or undefined when calling getAddressUsingGET.');
        }
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling getAddressUsingGET.');
        }
        if (offset === null || offset === undefined) {
            throw new Error('Required parameter offset was null or undefined when calling getAddressUsingGET.');
        }
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling getAddressUsingGET.');
        }
        if (format === null || format === undefined) {
            throw new Error('Required parameter format was null or undefined when calling getAddressUsingGET.');
        }
        if (api_code === null || api_code === undefined) {
            throw new Error('Required parameter api_code was null or undefined when calling getAddressUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (limit !== undefined) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (filter !== undefined) {
            queryParameters = queryParameters.set('filter', <any>filter);
        }
        if (format !== undefined) {
            queryParameters = queryParameters.set('format', <any>format);
        }
        if (api_code !== undefined) {
            queryParameters = queryParameters.set('api_code', <any>api_code);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<AddressFull>(`${this.basePath}/address/${encodeURIComponent(String(addr))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getBalance
     * 
     * @param active active
     * @param filter filter
     * @param api_code api_code
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getBalanceUsingPOST1(active: string, filter: number, api_code: string, observe?: 'body', reportProgress?: boolean): Observable<{ [key: string]: Balance; }>;
    public getBalanceUsingPOST1(active: string, filter: number, api_code: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{ [key: string]: Balance; }>>;
    public getBalanceUsingPOST1(active: string, filter: number, api_code: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<{ [key: string]: Balance; }>>;
    public getBalanceUsingPOST1(active: string, filter: number, api_code: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (active === null || active === undefined) {
            throw new Error('Required parameter active was null or undefined when calling getBalanceUsingPOST1.');
        }
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling getBalanceUsingPOST1.');
        }
        if (api_code === null || api_code === undefined) {
            throw new Error('Required parameter api_code was null or undefined when calling getBalanceUsingPOST1.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (active !== undefined) {
            queryParameters = queryParameters.set('active', <any>active);
        }
        if (filter !== undefined) {
            queryParameters = queryParameters.set('filter', <any>filter);
        }
        if (api_code !== undefined) {
            queryParameters = queryParameters.set('api_code', <any>api_code);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.post<{ [key: string]: Balance; }>(`${this.basePath}/balance`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getBlockDetails
     * 
     * @param block_hash block_hash
     * @param api_code api_code
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getBlockDetailsUsingGET(block_hash: string, api_code: string, observe?: 'body', reportProgress?: boolean): Observable<RawBlock>;
    public getBlockDetailsUsingGET(block_hash: string, api_code: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RawBlock>>;
    public getBlockDetailsUsingGET(block_hash: string, api_code: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RawBlock>>;
    public getBlockDetailsUsingGET(block_hash: string, api_code: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (block_hash === null || block_hash === undefined) {
            throw new Error('Required parameter block_hash was null or undefined when calling getBlockDetailsUsingGET.');
        }
        if (api_code === null || api_code === undefined) {
            throw new Error('Required parameter api_code was null or undefined when calling getBlockDetailsUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (api_code !== undefined) {
            queryParameters = queryParameters.set('api_code', <any>api_code);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<RawBlock>(`${this.basePath}/rawblock/${encodeURIComponent(String(block_hash))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getBlockDetails
     * 
     * @param block_index block_index
     * @param api_code api_code
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getBlockDetailsUsingGET1(block_index: number, api_code: string, observe?: 'body', reportProgress?: boolean): Observable<RawBlock>;
    public getBlockDetailsUsingGET1(block_index: number, api_code: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RawBlock>>;
    public getBlockDetailsUsingGET1(block_index: number, api_code: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RawBlock>>;
    public getBlockDetailsUsingGET1(block_index: number, api_code: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (block_index === null || block_index === undefined) {
            throw new Error('Required parameter block_index was null or undefined when calling getBlockDetailsUsingGET1.');
        }
        if (api_code === null || api_code === undefined) {
            throw new Error('Required parameter api_code was null or undefined when calling getBlockDetailsUsingGET1.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (api_code !== undefined) {
            queryParameters = queryParameters.set('api_code', <any>api_code);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<RawBlock>(`${this.basePath}/rawblock/${encodeURIComponent(String(block_index))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getBlocksAtHeight
     * 
     * @param block_height block-height
     * @param format format
     * @param api_code api_code
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getBlocksAtHeightUsingGET(block_height: number, format: string, api_code: string, observe?: 'body', reportProgress?: boolean): Observable<RawBlocks>;
    public getBlocksAtHeightUsingGET(block_height: number, format: string, api_code: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RawBlocks>>;
    public getBlocksAtHeightUsingGET(block_height: number, format: string, api_code: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RawBlocks>>;
    public getBlocksAtHeightUsingGET(block_height: number, format: string, api_code: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (block_height === null || block_height === undefined) {
            throw new Error('Required parameter block_height was null or undefined when calling getBlocksAtHeightUsingGET.');
        }
        if (format === null || format === undefined) {
            throw new Error('Required parameter format was null or undefined when calling getBlocksAtHeightUsingGET.');
        }
        if (api_code === null || api_code === undefined) {
            throw new Error('Required parameter api_code was null or undefined when calling getBlocksAtHeightUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (format !== undefined) {
            queryParameters = queryParameters.set('format', <any>format);
        }
        if (api_code !== undefined) {
            queryParameters = queryParameters.set('api_code', <any>api_code);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<RawBlocks>(`${this.basePath}/block-height/${encodeURIComponent(String(block_height))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getBlocksAtTime
     * 
     * @param time_in_milliseconds time_in_milliseconds
     * @param format format
     * @param api_code api_code
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getBlocksAtTimeUsingGET(time_in_milliseconds: number, format: string, api_code: string, observe?: 'body', reportProgress?: boolean): Observable<RawBlocks>;
    public getBlocksAtTimeUsingGET(time_in_milliseconds: number, format: string, api_code: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RawBlocks>>;
    public getBlocksAtTimeUsingGET(time_in_milliseconds: number, format: string, api_code: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RawBlocks>>;
    public getBlocksAtTimeUsingGET(time_in_milliseconds: number, format: string, api_code: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (time_in_milliseconds === null || time_in_milliseconds === undefined) {
            throw new Error('Required parameter time_in_milliseconds was null or undefined when calling getBlocksAtTimeUsingGET.');
        }
        if (format === null || format === undefined) {
            throw new Error('Required parameter format was null or undefined when calling getBlocksAtTimeUsingGET.');
        }
        if (api_code === null || api_code === undefined) {
            throw new Error('Required parameter api_code was null or undefined when calling getBlocksAtTimeUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (format !== undefined) {
            queryParameters = queryParameters.set('format', <any>format);
        }
        if (api_code !== undefined) {
            queryParameters = queryParameters.set('api_code', <any>api_code);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<RawBlocks>(`${this.basePath}/blocks/${encodeURIComponent(String(time_in_milliseconds))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getBlocksFromPool
     * 
     * @param pool_name pool_name
     * @param format format
     * @param api_code api_code
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getBlocksFromPoolUsingGET(pool_name: string, format: string, api_code: string, observe?: 'body', reportProgress?: boolean): Observable<RawBlocks>;
    public getBlocksFromPoolUsingGET(pool_name: string, format: string, api_code: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RawBlocks>>;
    public getBlocksFromPoolUsingGET(pool_name: string, format: string, api_code: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RawBlocks>>;
    public getBlocksFromPoolUsingGET(pool_name: string, format: string, api_code: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (pool_name === null || pool_name === undefined) {
            throw new Error('Required parameter pool_name was null or undefined when calling getBlocksFromPoolUsingGET.');
        }
        if (format === null || format === undefined) {
            throw new Error('Required parameter format was null or undefined when calling getBlocksFromPoolUsingGET.');
        }
        if (api_code === null || api_code === undefined) {
            throw new Error('Required parameter api_code was null or undefined when calling getBlocksFromPoolUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (format !== undefined) {
            queryParameters = queryParameters.set('format', <any>format);
        }
        if (api_code !== undefined) {
            queryParameters = queryParameters.set('api_code', <any>api_code);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<RawBlocks>(`${this.basePath}/blocks/${encodeURIComponent(String(pool_name))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getExportHistory
     * 
     * @param active active
     * @param start start
     * @param end end
     * @param currency currency
     * @param api_code api_code
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getExportHistoryUsingGET(active: string, start: string, end: string, currency: string, api_code: string, observe?: 'body', reportProgress?: boolean): Observable<Array<ExportHistory>>;
    public getExportHistoryUsingGET(active: string, start: string, end: string, currency: string, api_code: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ExportHistory>>>;
    public getExportHistoryUsingGET(active: string, start: string, end: string, currency: string, api_code: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ExportHistory>>>;
    public getExportHistoryUsingGET(active: string, start: string, end: string, currency: string, api_code: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (active === null || active === undefined) {
            throw new Error('Required parameter active was null or undefined when calling getExportHistoryUsingGET.');
        }
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling getExportHistoryUsingGET.');
        }
        if (end === null || end === undefined) {
            throw new Error('Required parameter end was null or undefined when calling getExportHistoryUsingGET.');
        }
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling getExportHistoryUsingGET.');
        }
        if (api_code === null || api_code === undefined) {
            throw new Error('Required parameter api_code was null or undefined when calling getExportHistoryUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (active !== undefined) {
            queryParameters = queryParameters.set('active', <any>active);
        }
        if (start !== undefined) {
            queryParameters = queryParameters.set('start', <any>start);
        }
        if (end !== undefined) {
            queryParameters = queryParameters.set('end', <any>end);
        }
        if (currency !== undefined) {
            queryParameters = queryParameters.set('currency', <any>currency);
        }
        if (api_code !== undefined) {
            queryParameters = queryParameters.set('api_code', <any>api_code);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Array<ExportHistory>>(`${this.basePath}/v2/export-history`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getLatestBlock
     * 
     * @param api_code api_code
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getLatestBlockUsingGET(api_code: string, observe?: 'body', reportProgress?: boolean): Observable<Block>;
    public getLatestBlockUsingGET(api_code: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Block>>;
    public getLatestBlockUsingGET(api_code: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Block>>;
    public getLatestBlockUsingGET(api_code: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (api_code === null || api_code === undefined) {
            throw new Error('Required parameter api_code was null or undefined when calling getLatestBlockUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (api_code !== undefined) {
            queryParameters = queryParameters.set('api_code', <any>api_code);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Block>(`${this.basePath}/latestblock`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getMultiAddress
     * 
     * @param active active
     * @param n n
     * @param offset offset
     * @param filter filter
     * @param onlyShow onlyShow
     * @param api_code api_code
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMultiAddressUsingPOST1(active: string, n: number, offset: number, filter: number, onlyShow: string, api_code: string, observe?: 'body', reportProgress?: boolean): Observable<MultiAddress>;
    public getMultiAddressUsingPOST1(active: string, n: number, offset: number, filter: number, onlyShow: string, api_code: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<MultiAddress>>;
    public getMultiAddressUsingPOST1(active: string, n: number, offset: number, filter: number, onlyShow: string, api_code: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<MultiAddress>>;
    public getMultiAddressUsingPOST1(active: string, n: number, offset: number, filter: number, onlyShow: string, api_code: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (active === null || active === undefined) {
            throw new Error('Required parameter active was null or undefined when calling getMultiAddressUsingPOST1.');
        }
        if (n === null || n === undefined) {
            throw new Error('Required parameter n was null or undefined when calling getMultiAddressUsingPOST1.');
        }
        if (offset === null || offset === undefined) {
            throw new Error('Required parameter offset was null or undefined when calling getMultiAddressUsingPOST1.');
        }
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling getMultiAddressUsingPOST1.');
        }
        if (onlyShow === null || onlyShow === undefined) {
            throw new Error('Required parameter onlyShow was null or undefined when calling getMultiAddressUsingPOST1.');
        }
        if (api_code === null || api_code === undefined) {
            throw new Error('Required parameter api_code was null or undefined when calling getMultiAddressUsingPOST1.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (active !== undefined) {
            queryParameters = queryParameters.set('active', <any>active);
        }
        if (n !== undefined) {
            queryParameters = queryParameters.set('n', <any>n);
        }
        if (offset !== undefined) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (filter !== undefined) {
            queryParameters = queryParameters.set('filter', <any>filter);
        }
        if (onlyShow !== undefined) {
            queryParameters = queryParameters.set('onlyShow', <any>onlyShow);
        }
        if (api_code !== undefined) {
            queryParameters = queryParameters.set('api_code', <any>api_code);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.post<MultiAddress>(`${this.basePath}/multiaddr`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getTransactionDetails
     * 
     * @param tx_hash tx_hash
     * @param api_code api_code
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTransactionDetailsUsingGET(tx_hash: string, api_code: string, observe?: 'body', reportProgress?: boolean): Observable<Transaction>;
    public getTransactionDetailsUsingGET(tx_hash: string, api_code: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Transaction>>;
    public getTransactionDetailsUsingGET(tx_hash: string, api_code: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Transaction>>;
    public getTransactionDetailsUsingGET(tx_hash: string, api_code: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (tx_hash === null || tx_hash === undefined) {
            throw new Error('Required parameter tx_hash was null or undefined when calling getTransactionDetailsUsingGET.');
        }
        if (api_code === null || api_code === undefined) {
            throw new Error('Required parameter api_code was null or undefined when calling getTransactionDetailsUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (api_code !== undefined) {
            queryParameters = queryParameters.set('api_code', <any>api_code);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Transaction>(`${this.basePath}/rawtx/${encodeURIComponent(String(tx_hash))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getTransactionDetails
     * 
     * @param tx_index tx_index
     * @param api_code api_code
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTransactionDetailsUsingGET1(tx_index: number, api_code: string, observe?: 'body', reportProgress?: boolean): Observable<Transaction>;
    public getTransactionDetailsUsingGET1(tx_index: number, api_code: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Transaction>>;
    public getTransactionDetailsUsingGET1(tx_index: number, api_code: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Transaction>>;
    public getTransactionDetailsUsingGET1(tx_index: number, api_code: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (tx_index === null || tx_index === undefined) {
            throw new Error('Required parameter tx_index was null or undefined when calling getTransactionDetailsUsingGET1.');
        }
        if (api_code === null || api_code === undefined) {
            throw new Error('Required parameter api_code was null or undefined when calling getTransactionDetailsUsingGET1.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (api_code !== undefined) {
            queryParameters = queryParameters.set('api_code', <any>api_code);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Transaction>(`${this.basePath}/rawtx/${encodeURIComponent(String(tx_index))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getTransaction
     * 
     * @param hash hash
     * @param format format
     * @param api_code api_code
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTransactionUsingGET(hash: string, format: string, api_code: string, observe?: 'body', reportProgress?: boolean): Observable<Transaction>;
    public getTransactionUsingGET(hash: string, format: string, api_code: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Transaction>>;
    public getTransactionUsingGET(hash: string, format: string, api_code: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Transaction>>;
    public getTransactionUsingGET(hash: string, format: string, api_code: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (hash === null || hash === undefined) {
            throw new Error('Required parameter hash was null or undefined when calling getTransactionUsingGET.');
        }
        if (format === null || format === undefined) {
            throw new Error('Required parameter format was null or undefined when calling getTransactionUsingGET.');
        }
        if (api_code === null || api_code === undefined) {
            throw new Error('Required parameter api_code was null or undefined when calling getTransactionUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (format !== undefined) {
            queryParameters = queryParameters.set('format', <any>format);
        }
        if (api_code !== undefined) {
            queryParameters = queryParameters.set('api_code', <any>api_code);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Transaction>(`${this.basePath}/tx/${encodeURIComponent(String(hash))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getUnconfirmedTransactions
     * 
     * @param format format
     * @param api_code api_code
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUnconfirmedTransactionsUsingGET(format: string, api_code: string, observe?: 'body', reportProgress?: boolean): Observable<Transactions>;
    public getUnconfirmedTransactionsUsingGET(format: string, api_code: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Transactions>>;
    public getUnconfirmedTransactionsUsingGET(format: string, api_code: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Transactions>>;
    public getUnconfirmedTransactionsUsingGET(format: string, api_code: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (format === null || format === undefined) {
            throw new Error('Required parameter format was null or undefined when calling getUnconfirmedTransactionsUsingGET.');
        }
        if (api_code === null || api_code === undefined) {
            throw new Error('Required parameter api_code was null or undefined when calling getUnconfirmedTransactionsUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (format !== undefined) {
            queryParameters = queryParameters.set('format', <any>format);
        }
        if (api_code !== undefined) {
            queryParameters = queryParameters.set('api_code', <any>api_code);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Transactions>(`${this.basePath}/unconfirmed-transactions`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getUnspent
     * 
     * @param active active
     * @param confirmations confirmations
     * @param limit limit
     * @param api_code api_code
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUnspentUsingGET1(active: string, confirmations: number, limit: number, api_code: string, observe?: 'body', reportProgress?: boolean): Observable<UnspentOutputs>;
    public getUnspentUsingGET1(active: string, confirmations: number, limit: number, api_code: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UnspentOutputs>>;
    public getUnspentUsingGET1(active: string, confirmations: number, limit: number, api_code: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UnspentOutputs>>;
    public getUnspentUsingGET1(active: string, confirmations: number, limit: number, api_code: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (active === null || active === undefined) {
            throw new Error('Required parameter active was null or undefined when calling getUnspentUsingGET1.');
        }
        if (confirmations === null || confirmations === undefined) {
            throw new Error('Required parameter confirmations was null or undefined when calling getUnspentUsingGET1.');
        }
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling getUnspentUsingGET1.');
        }
        if (api_code === null || api_code === undefined) {
            throw new Error('Required parameter api_code was null or undefined when calling getUnspentUsingGET1.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (active !== undefined) {
            queryParameters = queryParameters.set('active', <any>active);
        }
        if (confirmations !== undefined) {
            queryParameters = queryParameters.set('confirmations', <any>confirmations);
        }
        if (limit !== undefined) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (api_code !== undefined) {
            queryParameters = queryParameters.set('api_code', <any>api_code);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<UnspentOutputs>(`${this.basePath}/unspent`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * pushTxWithSecret
     * 
     * @param tx tx
     * @param lock_secret lock_secret
     * @param api_code api_code
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public pushTxWithSecretUsingPOST(tx: string, lock_secret: string, api_code: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public pushTxWithSecretUsingPOST(tx: string, lock_secret: string, api_code: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public pushTxWithSecretUsingPOST(tx: string, lock_secret: string, api_code: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public pushTxWithSecretUsingPOST(tx: string, lock_secret: string, api_code: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (tx === null || tx === undefined) {
            throw new Error('Required parameter tx was null or undefined when calling pushTxWithSecretUsingPOST.');
        }
        if (lock_secret === null || lock_secret === undefined) {
            throw new Error('Required parameter lock_secret was null or undefined when calling pushTxWithSecretUsingPOST.');
        }
        if (api_code === null || api_code === undefined) {
            throw new Error('Required parameter api_code was null or undefined when calling pushTxWithSecretUsingPOST.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (tx !== undefined) {
            queryParameters = queryParameters.set('tx', <any>tx);
        }
        if (lock_secret !== undefined) {
            queryParameters = queryParameters.set('lock_secret', <any>lock_secret);
        }
        if (api_code !== undefined) {
            queryParameters = queryParameters.set('api_code', <any>api_code);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.post<string>(`${this.basePath}/pushtx`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
