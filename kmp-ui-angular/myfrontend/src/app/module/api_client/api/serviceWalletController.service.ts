/**
 * KMP API
 * KMP 에서 제공하는 API를 확인하고 테스트 해볼 수 있습니다.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: jdlee726@gmail.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { CreateWalletResponse } from '../model/createWalletResponse';
import { WalletAddress } from '../model/walletAddress';
import { WalletAddressArchiveResponse } from '../model/walletAddressArchiveResponse';
import { WalletAddressList } from '../model/walletAddressList';
import { WalletAddressUnarchiveResponse } from '../model/walletAddressUnarchiveResponse';
import { WalletBalance } from '../model/walletBalance';
import { WalletPaymentResponse } from '../model/walletPaymentResponse';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class ServiceWalletControllerService {

    protected basePath = 'https://localhost:8080';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * archiveAddress
     * 
     * @param guid guid
     * @param password password
     * @param api_code api_code
     * @param address address
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public archiveAddressUsingGET(guid: string, password: string, api_code: string, address: string, observe?: 'body', reportProgress?: boolean): Observable<WalletAddressArchiveResponse>;
    public archiveAddressUsingGET(guid: string, password: string, api_code: string, address: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<WalletAddressArchiveResponse>>;
    public archiveAddressUsingGET(guid: string, password: string, api_code: string, address: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<WalletAddressArchiveResponse>>;
    public archiveAddressUsingGET(guid: string, password: string, api_code: string, address: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (guid === null || guid === undefined) {
            throw new Error('Required parameter guid was null or undefined when calling archiveAddressUsingGET.');
        }
        if (password === null || password === undefined) {
            throw new Error('Required parameter password was null or undefined when calling archiveAddressUsingGET.');
        }
        if (api_code === null || api_code === undefined) {
            throw new Error('Required parameter api_code was null or undefined when calling archiveAddressUsingGET.');
        }
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling archiveAddressUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (password !== undefined) {
            queryParameters = queryParameters.set('password', <any>password);
        }
        if (api_code !== undefined) {
            queryParameters = queryParameters.set('api_code', <any>api_code);
        }
        if (address !== undefined) {
            queryParameters = queryParameters.set('address', <any>address);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<WalletAddressArchiveResponse>(`${this.basePath}/merchant/${encodeURIComponent(String(guid))}/archive_address`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * createWallet
     * 
     * @param password password
     * @param api_code api_code
     * @param priv priv
     * @param label label
     * @param email email
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createWalletUsingGET(password: string, api_code: string, priv: string, label: string, email: string, observe?: 'body', reportProgress?: boolean): Observable<CreateWalletResponse>;
    public createWalletUsingGET(password: string, api_code: string, priv: string, label: string, email: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CreateWalletResponse>>;
    public createWalletUsingGET(password: string, api_code: string, priv: string, label: string, email: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CreateWalletResponse>>;
    public createWalletUsingGET(password: string, api_code: string, priv: string, label: string, email: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (password === null || password === undefined) {
            throw new Error('Required parameter password was null or undefined when calling createWalletUsingGET.');
        }
        if (api_code === null || api_code === undefined) {
            throw new Error('Required parameter api_code was null or undefined when calling createWalletUsingGET.');
        }
        if (priv === null || priv === undefined) {
            throw new Error('Required parameter priv was null or undefined when calling createWalletUsingGET.');
        }
        if (label === null || label === undefined) {
            throw new Error('Required parameter label was null or undefined when calling createWalletUsingGET.');
        }
        if (email === null || email === undefined) {
            throw new Error('Required parameter email was null or undefined when calling createWalletUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (password !== undefined) {
            queryParameters = queryParameters.set('password', <any>password);
        }
        if (api_code !== undefined) {
            queryParameters = queryParameters.set('api_code', <any>api_code);
        }
        if (priv !== undefined) {
            queryParameters = queryParameters.set('priv', <any>priv);
        }
        if (label !== undefined) {
            queryParameters = queryParameters.set('label', <any>label);
        }
        if (email !== undefined) {
            queryParameters = queryParameters.set('email', <any>email);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<CreateWalletResponse>(`${this.basePath}/api/v2/create`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getAddress
     * 
     * @param guid guid
     * @param password password
     * @param api_code api_code
     * @param address address
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAddressUsingGET1(guid: string, password: string, api_code: string, address: string, observe?: 'body', reportProgress?: boolean): Observable<WalletAddress>;
    public getAddressUsingGET1(guid: string, password: string, api_code: string, address: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<WalletAddress>>;
    public getAddressUsingGET1(guid: string, password: string, api_code: string, address: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<WalletAddress>>;
    public getAddressUsingGET1(guid: string, password: string, api_code: string, address: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (guid === null || guid === undefined) {
            throw new Error('Required parameter guid was null or undefined when calling getAddressUsingGET1.');
        }
        if (password === null || password === undefined) {
            throw new Error('Required parameter password was null or undefined when calling getAddressUsingGET1.');
        }
        if (api_code === null || api_code === undefined) {
            throw new Error('Required parameter api_code was null or undefined when calling getAddressUsingGET1.');
        }
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling getAddressUsingGET1.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (password !== undefined) {
            queryParameters = queryParameters.set('password', <any>password);
        }
        if (api_code !== undefined) {
            queryParameters = queryParameters.set('api_code', <any>api_code);
        }
        if (address !== undefined) {
            queryParameters = queryParameters.set('address', <any>address);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<WalletAddress>(`${this.basePath}/merchant/${encodeURIComponent(String(guid))}/address_balance`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getBalance
     * 
     * @param guid guid
     * @param password password
     * @param api_code api_code
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getBalanceUsingGET(guid: string, password: string, api_code: string, observe?: 'body', reportProgress?: boolean): Observable<WalletBalance>;
    public getBalanceUsingGET(guid: string, password: string, api_code: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<WalletBalance>>;
    public getBalanceUsingGET(guid: string, password: string, api_code: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<WalletBalance>>;
    public getBalanceUsingGET(guid: string, password: string, api_code: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (guid === null || guid === undefined) {
            throw new Error('Required parameter guid was null or undefined when calling getBalanceUsingGET.');
        }
        if (password === null || password === undefined) {
            throw new Error('Required parameter password was null or undefined when calling getBalanceUsingGET.');
        }
        if (api_code === null || api_code === undefined) {
            throw new Error('Required parameter api_code was null or undefined when calling getBalanceUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (password !== undefined) {
            queryParameters = queryParameters.set('password', <any>password);
        }
        if (api_code !== undefined) {
            queryParameters = queryParameters.set('api_code', <any>api_code);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<WalletBalance>(`${this.basePath}/merchant/${encodeURIComponent(String(guid))}/balance`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * listAddresses
     * 
     * @param guid guid
     * @param password password
     * @param api_code api_code
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listAddressesUsingGET(guid: string, password: string, api_code: string, observe?: 'body', reportProgress?: boolean): Observable<WalletAddressList>;
    public listAddressesUsingGET(guid: string, password: string, api_code: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<WalletAddressList>>;
    public listAddressesUsingGET(guid: string, password: string, api_code: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<WalletAddressList>>;
    public listAddressesUsingGET(guid: string, password: string, api_code: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (guid === null || guid === undefined) {
            throw new Error('Required parameter guid was null or undefined when calling listAddressesUsingGET.');
        }
        if (password === null || password === undefined) {
            throw new Error('Required parameter password was null or undefined when calling listAddressesUsingGET.');
        }
        if (api_code === null || api_code === undefined) {
            throw new Error('Required parameter api_code was null or undefined when calling listAddressesUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (password !== undefined) {
            queryParameters = queryParameters.set('password', <any>password);
        }
        if (api_code !== undefined) {
            queryParameters = queryParameters.set('api_code', <any>api_code);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<WalletAddressList>(`${this.basePath}/merchant/${encodeURIComponent(String(guid))}/list`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * newAddress
     * 
     * @param guid guid
     * @param password password
     * @param api_code api_code
     * @param label label
     * @param second_password second_password
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public newAddressUsingGET(guid: string, password: string, api_code: string, label: string, second_password?: string, observe?: 'body', reportProgress?: boolean): Observable<WalletAddress>;
    public newAddressUsingGET(guid: string, password: string, api_code: string, label: string, second_password?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<WalletAddress>>;
    public newAddressUsingGET(guid: string, password: string, api_code: string, label: string, second_password?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<WalletAddress>>;
    public newAddressUsingGET(guid: string, password: string, api_code: string, label: string, second_password?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (guid === null || guid === undefined) {
            throw new Error('Required parameter guid was null or undefined when calling newAddressUsingGET.');
        }
        if (password === null || password === undefined) {
            throw new Error('Required parameter password was null or undefined when calling newAddressUsingGET.');
        }
        if (api_code === null || api_code === undefined) {
            throw new Error('Required parameter api_code was null or undefined when calling newAddressUsingGET.');
        }
        if (label === null || label === undefined) {
            throw new Error('Required parameter label was null or undefined when calling newAddressUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (password !== undefined) {
            queryParameters = queryParameters.set('password', <any>password);
        }
        if (second_password !== undefined) {
            queryParameters = queryParameters.set('second_password', <any>second_password);
        }
        if (api_code !== undefined) {
            queryParameters = queryParameters.set('api_code', <any>api_code);
        }
        if (label !== undefined) {
            queryParameters = queryParameters.set('label', <any>label);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<WalletAddress>(`${this.basePath}/merchant/${encodeURIComponent(String(guid))}/new_address`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * send
     * 
     * @param guid guid
     * @param method method
     * @param password password
     * @param second_password second_password
     * @param api_code api_code
     * @param to to
     * @param amount amount
     * @param recipients recipients
     * @param from from
     * @param fee fee
     * @param note note
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public sendUsingGET(guid: string, method: string, password: string, second_password: string, api_code: string, to: string, amount: string, recipients: string, from: string, fee: number, note: string, observe?: 'body', reportProgress?: boolean): Observable<WalletPaymentResponse>;
    public sendUsingGET(guid: string, method: string, password: string, second_password: string, api_code: string, to: string, amount: string, recipients: string, from: string, fee: number, note: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<WalletPaymentResponse>>;
    public sendUsingGET(guid: string, method: string, password: string, second_password: string, api_code: string, to: string, amount: string, recipients: string, from: string, fee: number, note: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<WalletPaymentResponse>>;
    public sendUsingGET(guid: string, method: string, password: string, second_password: string, api_code: string, to: string, amount: string, recipients: string, from: string, fee: number, note: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (guid === null || guid === undefined) {
            throw new Error('Required parameter guid was null or undefined when calling sendUsingGET.');
        }
        if (method === null || method === undefined) {
            throw new Error('Required parameter method was null or undefined when calling sendUsingGET.');
        }
        if (password === null || password === undefined) {
            throw new Error('Required parameter password was null or undefined when calling sendUsingGET.');
        }
        if (second_password === null || second_password === undefined) {
            throw new Error('Required parameter second_password was null or undefined when calling sendUsingGET.');
        }
        if (api_code === null || api_code === undefined) {
            throw new Error('Required parameter api_code was null or undefined when calling sendUsingGET.');
        }
        if (to === null || to === undefined) {
            throw new Error('Required parameter to was null or undefined when calling sendUsingGET.');
        }
        if (amount === null || amount === undefined) {
            throw new Error('Required parameter amount was null or undefined when calling sendUsingGET.');
        }
        if (recipients === null || recipients === undefined) {
            throw new Error('Required parameter recipients was null or undefined when calling sendUsingGET.');
        }
        if (from === null || from === undefined) {
            throw new Error('Required parameter from was null or undefined when calling sendUsingGET.');
        }
        if (fee === null || fee === undefined) {
            throw new Error('Required parameter fee was null or undefined when calling sendUsingGET.');
        }
        if (note === null || note === undefined) {
            throw new Error('Required parameter note was null or undefined when calling sendUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (password !== undefined) {
            queryParameters = queryParameters.set('password', <any>password);
        }
        if (second_password !== undefined) {
            queryParameters = queryParameters.set('second_password', <any>second_password);
        }
        if (api_code !== undefined) {
            queryParameters = queryParameters.set('api_code', <any>api_code);
        }
        if (to !== undefined) {
            queryParameters = queryParameters.set('to', <any>to);
        }
        if (amount !== undefined) {
            queryParameters = queryParameters.set('amount', <any>amount);
        }
        if (recipients !== undefined) {
            queryParameters = queryParameters.set('recipients', <any>recipients);
        }
        if (from !== undefined) {
            queryParameters = queryParameters.set('from', <any>from);
        }
        if (fee !== undefined) {
            queryParameters = queryParameters.set('fee', <any>fee);
        }
        if (note !== undefined) {
            queryParameters = queryParameters.set('note', <any>note);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<WalletPaymentResponse>(`${this.basePath}/merchant/${encodeURIComponent(String(guid))}/${encodeURIComponent(String(method))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * unarchiveAddress
     * 
     * @param guid guid
     * @param password password
     * @param api_code api_code
     * @param address address
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public unarchiveAddressUsingGET(guid: string, password: string, api_code: string, address: string, observe?: 'body', reportProgress?: boolean): Observable<WalletAddressUnarchiveResponse>;
    public unarchiveAddressUsingGET(guid: string, password: string, api_code: string, address: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<WalletAddressUnarchiveResponse>>;
    public unarchiveAddressUsingGET(guid: string, password: string, api_code: string, address: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<WalletAddressUnarchiveResponse>>;
    public unarchiveAddressUsingGET(guid: string, password: string, api_code: string, address: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (guid === null || guid === undefined) {
            throw new Error('Required parameter guid was null or undefined when calling unarchiveAddressUsingGET.');
        }
        if (password === null || password === undefined) {
            throw new Error('Required parameter password was null or undefined when calling unarchiveAddressUsingGET.');
        }
        if (api_code === null || api_code === undefined) {
            throw new Error('Required parameter api_code was null or undefined when calling unarchiveAddressUsingGET.');
        }
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling unarchiveAddressUsingGET.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (password !== undefined) {
            queryParameters = queryParameters.set('password', <any>password);
        }
        if (api_code !== undefined) {
            queryParameters = queryParameters.set('api_code', <any>api_code);
        }
        if (address !== undefined) {
            queryParameters = queryParameters.set('address', <any>address);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<WalletAddressUnarchiveResponse>(`${this.basePath}/merchant/${encodeURIComponent(String(guid))}/unarchive_address`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
